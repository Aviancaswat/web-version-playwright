
// =============================== Version 1 ===========================

export const replaceDataforNewTest = async (newTestData: string) => {
    const datas = transformerData(newTestData);
    console.log("datas: ", datas);
    
    if (!datas || datas.length === 0) return;
    
    const commitResults = [];
    
    // Ejecutar commits secuencialmente en lugar de concurrentemente
    for (let i = 0; i < datas.length; i++) {
        const data = datas[i];
        
        try {
            console.log(`\n--- Procesando commit ${i + 1}/${datas.length} ---`);
            
            // Obtener la versión más reciente del archivo antes de cada commit
            let fileData = await getFileData();
            console.log(`SHA actual para commit ${i + 1}: `, fileData.sha);
            
            // Decodificar el contenido actual
            let fileContent = atob(fileData.content);
            
            // Reemplazar el contenido con el nuevo array de datos
            const updatedContent = fileContent.replace(
                /\[\s*{[\s\S]*?}\s*]/, 
                JSON.stringify(data, null, 2)
            );
            
            // Crear el commit
            const response = await octokit.request('PUT /repos/{owner}/{repo}/contents/{path}', {
                owner: owner,
                repo: repo,
                path: path,
                message: `Commit desde la api - ${getTimestamp()} - Test ${i + 1}`,
                content: btoa(updatedContent),
                sha: fileData.sha,
                branch: branchRef
            });
            
            console.log(`✅ Commit ${i + 1} realizado exitosamente`);
            console.log(`Nuevo SHA del commit: `, response.data.commit?.sha);
            console.log(`Nuevo SHA del contenido: `, response.data.content?.sha);
            
            commitResults.push({
                index: i + 1,
                success: true,
                commitSha: response.data.commit?.sha,
                contentSha: response.data.content?.sha,
                data: data
            });
            
            // Opcional: Agregar un pequeño delay entre commits para evitar rate limiting
            if (i < datas.length - 1) {
                console.log(`Esperando 2 segundos antes del siguiente commit...`);
                await new Promise(resolve => setTimeout(resolve, 2000));
            }
            
        } catch (error) {
            console.error(`❌ Error en commit ${i + 1}:`, error);
            commitResults.push({
                index: i + 1,
                success: false,
                error: error.message,
                data: data
            });
            
            // Opcional: Decidir si continuar o parar en caso de error
            // throw error; // Descomentar si quieres parar en el primer error
        }
    }
    
    // Resumen final
    console.log('\n=== RESUMEN DE COMMITS ===');
    console.log(`Total de elementos procesados: ${datas.length}`);
    console.log(`Commits exitosos: ${commitResults.filter(r => r.success).length}`);
    console.log(`Commits fallidos: ${commitResults.filter(r => !r.success).length}`);
    
    commitResults.forEach(result => {
        if (result.success) {
            console.log(`✅ Commit ${result.index}: SHA ${result.commitSha}`);
        } else {
            console.log(`❌ Commit ${result.index}: ${result.error}`);
        }
    });
    
    return commitResults;
};

// Función auxiliar mejorada para obtener datos del archivo con retry
const getFileData = async (retries = 3): Promise<any> => {
    for (let i = 0; i < retries; i++) {
        try {
            const response = await octokit.request('GET /repos/{owner}/{repo}/contents/{path}', {
                owner: owner,
                repo: repo,
                path: path,
                ref: branchRef
            });
            return response.data;
        } catch (error) {
            console.warn(`Intento ${i + 1} fallido al obtener archivo:`, error.message);
            if (i === retries - 1) throw error;
            
            // Esperar un poco antes de reintentar
            await new Promise(resolve => setTimeout(resolve, 1000));
        }
    }
};

// Versión alternativa con mejor manejo de errores y rollback
export const replaceDataforNewTestWithRollback = async (newTestData: string) => {
    const datas = transformerData(newTestData);
    console.log("datas: ", datas);
    
    if (!datas || datas.length === 0) return;
    
    const commitResults = [];
    const originalFileData = await getFileData(); // Backup del estado original
    
    for (let i = 0; i < datas.length; i++) {
        const data = datas[i];
        
        try {
            console.log(`\n--- Procesando commit ${i + 1}/${datas.length} ---`);
            
            let fileData = await getFileData();
            console.log(`SHA actual para commit ${i + 1}: `, fileData.sha);
            
            let fileContent = atob(fileData.content);
            const updatedContent = fileContent.replace(
                /\[\s*{[\s\S]*?}\s*]/, 
                JSON.stringify(data, null, 2)
            );
            
            const response = await octokit.request('PUT /repos/{owner}/{repo}/contents/{path}', {
                owner: owner,
                repo: repo,
                path: path,
                message: `Commit desde la api - ${getTimestamp()} - Test ${i + 1}`,
                content: btoa(updatedContent),
                sha: fileData.sha,
                branch: branchRef
            });
            
            console.log(`✅ Commit ${i + 1} realizado exitosamente`);
            
            commitResults.push({
                index: i + 1,
                success: true,
                commitSha: response.data.commit?.sha,
                contentSha: response.data.content?.sha,
                data: data
            });
            
            // Esperar entre commits
            if (i < datas.length - 1) {
                await new Promise(resolve => setTimeout(resolve, 2000));
            }
            
        } catch (error) {
            console.error(`❌ Error en commit ${i + 1}:`, error);
            
            // En caso de error crítico, podrías restaurar el archivo original
            if (error.status === 409) { // Conflict
                console.log('Conflicto detectado, obteniendo última versión...');
                continue; // Intentar de nuevo con la nueva versión
            }
            
            commitResults.push({
                index: i + 1,
                success: false,
                error: error.message,
                data: data
            });
            
            break; // Parar en caso de error
        }
    }
    
    return commitResults;
};


// ====================================== VERSION 2 ========================================

export const replaceDataforNewTest = async (newTestData: string) => {
    const datas = transformerData(newTestData);
    console.log("datas: ", datas);
    
    if (!datas || datas.length === 0) return;
    
    const commitResults = [];
    
    // Ejecutar commits secuencialmente en lugar de concurrentemente
    for (let i = 0; i < datas.length; i++) {
        const data = datas[i];
        
        try {
            console.log(`\n--- Procesando commit ${i + 1}/${datas.length} ---`);
            
            // Obtener la versión más reciente del archivo antes de cada commit
            let fileData = await getFileData();
            console.log(`SHA actual para commit ${i + 1}: `, fileData.sha);
            
            // Decodificar el contenido actual
            let fileContent = atob(fileData.content);
            
            // Reemplazar el contenido con el nuevo array de datos
            const updatedContent = fileContent.replace(
                /\[\s*{[\s\S]*?}\s*]/, 
                JSON.stringify(data, null, 2)
            );
            
            // Crear el commit
            const response = await octokit.request('PUT /repos/{owner}/{repo}/contents/{path}', {
                owner: owner,
                repo: repo,
                path: path,
                message: `Commit desde la api - ${getTimestamp()} - Test ${i + 1}`,
                content: btoa(updatedContent),
                sha: fileData.sha,
                branch: branchRef
            });
            
            console.log(`✅ Commit ${i + 1} realizado exitosamente`);
            console.log(`Nuevo SHA del commit: `, response.data.commit?.sha);
            console.log(`Nuevo SHA del contenido: `, response.data.content?.sha);
            
            commitResults.push({
                index: i + 1,
                success: true,
                commitSha: response.data.commit?.sha,
                contentSha: response.data.content?.sha,
                data: data
            });
            
            // Opcional: Agregar un pequeño delay entre commits para evitar rate limiting
            if (i < datas.length - 1) {
                console.log(`Esperando 2 segundos antes del siguiente commit...`);
                await new Promise(resolve => setTimeout(resolve, 2000));
            }
            
        } catch (error) {
            console.error(`❌ Error en commit ${i + 1}:`, error);
            commitResults.push({
                index: i + 1,
                success: false,
                error: error.message,
                data: data
            });
            
            // Opcional: Decidir si continuar o parar en caso de error
            // throw error; // Descomentar si quieres parar en el primer error
        }
    }
    
    // Resumen final
    console.log('\n=== RESUMEN DE COMMITS ===');
    console.log(`Total de elementos procesados: ${datas.length}`);
    console.log(`Commits exitosos: ${commitResults.filter(r => r.success).length}`);
    console.log(`Commits fallidos: ${commitResults.filter(r => !r.success).length}`);
    
    commitResults.forEach(result => {
        if (result.success) {
            console.log(`✅ Commit ${result.index}: SHA ${result.commitSha}`);
        } else {
            console.log(`❌ Commit ${result.index}: ${result.error}`);
        }
    });
    
    return commitResults;
};

// Función auxiliar mejorada para obtener datos del archivo con retry
const getFileDataWithRetry = async (maxRetries = 5): Promise<any> => {
    for (let i = 0; i < maxRetries; i++) {
        try {
            // Agregar un timestamp como query param para evitar cache
            const timestamp = Date.now();
            
            const response = await octokit.request('GET /repos/{owner}/{repo}/contents/{path}', {
                owner: owner,
                repo: repo,
                path: path,
                ref: branchRef,
                // Forzar obtener la versión más reciente
                headers: {
                    'Cache-Control': 'no-cache',
                    'If-None-Match': ''
                }
            });
            
            console.log(`✅ Archivo obtenido correctamente (intento ${i + 1}), SHA: ${response.data.sha}`);
            return response.data;
            
        } catch (error) {
            console.warn(`⚠️  Intento ${i + 1}/${maxRetries} fallido al obtener archivo:`, error.message);
            
            if (i === maxRetries - 1) {
                console.error('❌ No se pudo obtener el archivo después de todos los reintentos');
                throw error;
            }
            
            // Esperar más tiempo en cada reintento
            const waitTime = (i + 1) * 2000; // 2s, 4s, 6s, 8s, 10s
            console.log(`⏳ Esperando ${waitTime}ms antes del siguiente intento...`);
            await new Promise(resolve => setTimeout(resolve, waitTime));
        }
    }
};

// Versión alternativa con mejor manejo de errores y rollback
export const replaceDataforNewTestWithRollback = async (newTestData: string) => {
    const datas = transformerData(newTestData);
    console.log("datas: ", datas);
    
    if (!datas || datas.length === 0) return;
    
    const commitResults = [];
    const originalFileData = await getFileData(); // Backup del estado original
    
    for (let i = 0; i < datas.length; i++) {
        const data = datas[i];
        
        try {
            console.log(`\n--- Procesando commit ${i + 1}/${datas.length} ---`);
            
            let fileData = await getFileData();
            console.log(`SHA actual para commit ${i + 1}: `, fileData.sha);
            
            let fileContent = atob(fileData.content);
            const updatedContent = fileContent.replace(
                /\[\s*{[\s\S]*?}\s*]/, 
                JSON.stringify(data, null, 2)
            );
            
            const response = await octokit.request('PUT /repos/{owner}/{repo}/contents/{path}', {
                owner: owner,
                repo: repo,
                path: path,
                message: `Commit desde la api - ${getTimestamp()} - Test ${i + 1}`,
                content: btoa(updatedContent),
                sha: fileData.sha,
                branch: branchRef
            });
            
            console.log(`✅ Commit ${i + 1} realizado exitosamente`);
            
            commitResults.push({
                index: i + 1,
                success: true,
                commitSha: response.data.commit?.sha,
                contentSha: response.data.content?.sha,
                data: data
            });
            
            // Esperar entre commits
            if (i < datas.length - 1) {
                await new Promise(resolve => setTimeout(resolve, 2000));
            }
            
        } catch (error) {
            console.error(`❌ Error en commit ${i + 1}:`, error);
            
            // En caso de error crítico, podrías restaurar el archivo original
            if (error.status === 409) { // Conflict
                console.log('Conflicto detectado, obteniendo última versión...');
                continue; // Intentar de nuevo con la nueva versión
            }
            
            commitResults.push({
                index: i + 1,
                success: false,
                error: error.message,
                data: data
            });
            
            break; // Parar en caso de error
        }
    }
    
    return commitResults;
};